<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>葡萄藤PPT</title>

   <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
     <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    
</head>

<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>什么是Filter，什么是Interceptor,他们的区别是什么，和AOP又是什么关系？  </h2>
            <h3>java小课堂</h3>
			<p>分享人：白云中</p>
        </section>

        <section>
            <p>目录</p>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>

        <section>
            <section>
                <h3>1.背景介绍</h3>
            </section>

            <section style="text-align: left;">
                <br style="text-align: left">
                <h3>Filter是什么</h3>
                过滤器是 Servlet 容器中的一个组件，主要负责处理请求和响应。<br>
				具体来说是负责对请求(HttpServletRequest)进行预处理， 以及对响应（HttpServletResponse）进行后处理，<br>
				在实现上，基于函数回调，它可以对几乎所有请求进行过滤，所以它是依赖 Servlet 容器的。</p>
            </section>
			
			<section style="text-align: left;">
				<h3>Interceptor是什么</h3>
				<p style="text-align:left">拦截器Spring容器的一个组件，SpringMVC拦截器（Interceptor）实现对每一个请求处理前后进行相关的业务处理，类似与servlet中的Filter。<br>
				  SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor来实现的。<br>
				在实现上,基于Java的反射机制的。<br>
				<br>
			</p>
			</section>
			
			<section style="text-align: left;">
				<h3>AOP是什么</h3>
				<p style="text-align:left"> AOP（Aspect-Oriented Programming）面向切片编程是一种编程思想，是对OOP面对对象编程的一种补充。<br>
				AOP利用称为"横切"的技术，剖解开封装的对象内部，把多个类的公共行为封装到一个可重用模块中，便于减少重复代码，降低模块之间的耦合度，AOP符合开闭原则，提高了代码的可拓展性。<br>
				  OOP的Objects 都可以只专注于自己的事情，而不需要去管用户是否登录以及记录本次操作日志的事情了。 <br>
				而且关于用户的判断以及日志记录的代码也只需要一份，不再关心需要将这些额外的操作加在哪里。<br>
				<br>
			</p>
			</section>
			
			<section style="text-align: left;">
				
				<p style="text-align:left"> 
				<img src="C:\Users\baiyunzhong\Desktop\AOP.png" />
				<br>
			</p>
			</section>
        </section>

        <section>

            <section>
                <h3>2.知识剖析</h3>
            </section>

            

            <section style="text-align: left;">
                <section style="text-align: center;"><strong><h3>Filter 的使用</h3></strong></section>
               (1)创建Filter 处理类<br>
                       init方法、destory方法、doFilter方法<br>
                       (2)在web.xml 文件中配置Filter<br>
				<section style="text-align: center;"><strong><h3>Filter的原理</h3></strong></section>
               (1)在ServletRequest 到达Servlet 之前，拦截客户的ServletRequest<br>
                (2)根据需要检查ServletRequest ，也可以修改ServletRequest 数据<br>
                 (3)根据需要检查ServletResponse ，可以修改ServletResponse 数据<br>
            </section>
            
            
			<section style="text-align: left;">
				<h3>Interceptor使用</h3>
             
               (1)创建interceptor 处理类，实现HandlerInterceptor接口<br>
                       复写preHandle()、postHandle()和afterCompletion()来对用户的请求进行拦截处理<br>
                       (2)在spring-mvc.xml文件的配置Interceptor<br>
				
            </section>	

			<section style="text-align: left;">
                <h3>Interceptor的原理</h3>
               (1)请求到达 DispatcherServlet<br>
                (2)DispatcherServlet 发送至 Interceptor ，执行 preHandle，返回 boolean 值，true 表示继续执行，false 为停止执行并返回。<br>
                 (3)请求达到 Controller<br>
				 (4)请求结束后，postHandle 执行， 可以在返回之前对返回的结果进行修改<br>
				 (5)在请求完全结束后调用，afterCompletion() – 可以用来统计请求耗时等等<br>
            </section>			
                             
        </section>

        <section>
            <section>
                <h3>3.常见问题</h3>
            </section>
             <section style="text-align: left;">
                Filter与interceptor的区别
            </section>
			
        </section>


        <section>
            <section>
                <h3>4.解决方案</h3>
            </section>
			<section style="text-align: left;">
             <h3>(1) 接口定义不同</h3>
			Filter 接口定义在 javax.servlet 包中,<br>
			接口 HandlerInterceptor 定义在org.springframework.web.servlet 包中
			</section>
			
			<section style="text-align: left;">
			<h3>(2) 规范不同</h3>
			Filter 是在 Servlet 规范中定义的，是 Servlet 容器支持的<br>
			Interceptor拦截器是在 Spring容器内的，是Spring框架支持的
			</section>
			
			<section style="text-align: left;">
			<h3>(3) 使用资源不同</h3>
			Filter 不能够使用 Spring 容器资源<br>
			拦截器是一个Spring的组件，归Spring管理，因此能使用Spring里的任何资源、对象；
			</section>
			
			<section style="text-align: left;">
			<h3>(4) 深度不同</h3>
			Filter在只在 Servlet 前后起作用；<br>
			Interceptor拦截器能够深入到方法前后、异常抛出前后等。
			</section>
			
			<section style="text-align: left;">
			<h3>(5) 调用者不同</h3>
			Filter 是被 Servlet 调用；<br>
			Interceptor 是被 Spring 调用。<br>
            因此 Filter 总是优先于 Interceptor 执行
			</section>
			
			<section style="text-align: left;">
			<h3>（6）应用场景不同</h3>
			Filter：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。<br>
			比如过滤非法的 url，过滤敏感词，设置字符编码等。<br>
			Interceptor：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。<br> 
			比如判断登录，验证权限，记录日志等
			</section>
			
			
			
			
         </section>
         
         
        <section>
            <section>
                <h3>5.编码实战</h3>
            </section>
        </section>


        <section>
            <section>
                <h3>6.扩展思考</h3>
            </section>
			
			<section style="text-align: left;">
                <h3>多个过滤器执行顺序</h3>
               web 容器启动时初始化每个 filter 时，是按照 filter 配置节点出现的顺序来初始化的，<br>
			   当请求资源匹配多个 filter-mapping 时，filter 拦截资源是按照 filter-mapping 配置节出现的顺序来依次调用 doFilter() 方法的。<br>
			
            </section>
			
            <section style="text-align: left;">
                <h3>过滤器与拦截器的代码执行顺序</h3>
                过滤器在servlet启动后开始执行，进入页面访问开始执行拦截器<br>
            </section>
            

        </section>
           

        <section>
            <section>
                <h3>7.参考文献</h3>
            </section>

            <section>
                <p style="text-align: left">参考：<br>
                    <br>
                    （1）https://www.cnblogs.com/junzi2099/p/8022058.html<br>
                   （2）https://www.cnblogs.com/dugqing/p/8906013.html<br>
                    （3）https://blog.csdn.net/FU250/article/details/80292293
                    
                    
                    
                    
                </p>
            </section>
        </section>

        <section>
            <section>
                <h3>8.更多讨论</h3>
            </section>
        </section>

        <section>
            <!--<h4>鸣谢</h4>-->
            <p>感谢大家观看</p>
            <p>
                <small>BY : 白云中</small>
            </p>
        </section>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js "></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js "></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc "或"o "键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触
    Reveal.initialize({
        history: true,
        dependencies: [
            {src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js'},
            {src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js'},
            {src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true},
            {
                src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>
</body>

</html>
