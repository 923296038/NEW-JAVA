<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? './css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
	<style>
		.left{ text-align: left; }
	</style>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
           
		    <h2>RMI的简单介绍</h2>
            <p>分享人：殷路</p>	
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>            
            <p>4.编码实战</p>
            <p>5.扩展思考</p>
            <p>6.参考文献</p>
            <p>7.更多讨论</p>
        </section>
         <section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
            <section style="top: 267px; display: block;" class="" aria-hidden="true">
                <h3>1.背景介绍</h3>
            </section>
            <section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				
				<p>RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。</p>
				<p></p>
            </section>
			 <section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>Java RMI：Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p>
				<p></p>
				<p></p>
            </section>
        </section>
		<section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
				<h3>2.知识剖析</h3>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p></p>
				<p>RMI应用程序通常包括两个独立的程序：服务器程序和客户机程序。

       典型的服务器应用程序将创建多个远程对象，使这些远程对象能够被引用，然后等待客户机调用这些远程对象的方法。 而典型的客户机程序则从服务器中得到一个或多个远程对象的引用，然后调用远程对象的方法。</p>				
				<p></p>
				<p></p>
				<p></p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">	
                		
				<p>RMI由3个部分构成，第一个是rmiregistry（JDK提供的一个可以独立运行的程序，在bin目录下），第二个是server端的程序，对外提供远程对象，第三个是client端的程序，想要调用远程对象的方法。
首先，先启动rmiregistry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。
其次，server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到rmiregistry上并对外暴露一个名称。
最后，client端通过本地的接口和一个已知的名称（即rmiregistry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMIService那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了。
</p>				
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
			    <p> RMI（远程方法调用）原理示意图</p>
				<p><img src="https://ylcom-1258882338.cos.ap-chengdu.myqcloud.com/E%3A%5Cupload%5Crmi_01.jpg" ></p>				
				<p></p>
				<p></p>
			</section>	
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>方法调用从客户对象经占位程序（Stub)、远程引用层(Remote Reference Layer)和传输层（Transport Layer）向下，传递给主机，然后再次经传 输层，向上穿过远程调用层和骨干网（Skeleton），到达服务器对象。 占位程序扮演着远程服务器对象的代理的角色，使该对象可被客户激活。 远程引用层处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。传输层管理实际的连接，并且追踪可以接受方法调用的远程对象。服务器端的骨干网完成对服务器对象实际的方法调用，并获取返回值。返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，占位程序获得返回值。</p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
			</section>	
            <section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>如何实现一个RMI程序</p>				
				<p>1.创建远程接口， 并且继承java.rmi.Remote接口。</p>
				<p>2.实现远程接口，并且继承：UnicastRemoteObject</p>
				<p>3.创建服务器程序： createRegistry方法注册远程对象，暴露一个监听</p>		
                <p>4.创建客户端程序，通过ip和端口连接到指定的服务器，并且将数据做封装（序列化）</p>
				<p>5.服务器端收到请求，先反序列化。再进行业务逻辑处理。把返回结果序列化返回</p>	
                <p></p>
				<p></p>
				<p></p>
			</section>							
		</section>
		<section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
				<h3>3.常见问题</h3>
			</section>	
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p> RMI的主要优点有哪些？</p>				
				<p>1.RMI是Java编写的, 具有 “编写一次，到处运行 ” 的特性。任何基于RMI的系统均可100%地移植到 任何Java虚拟机上</p>
				<p>2.面向对象：RMI可将完整的对象作为参数和返回值进行传递直接通过网络传输对象数据。</p>
                <p>3.可移动属性：RMI可将属性从客户机移动到服务器，或者从服务器移到客户机。</p>
				<p>4.设计方式：对象传递功能使您可以在分布式计算中充分利用面向对象技术的强大功能。</p>					
				<p>5.安全：RMI使用Java内置的安全机制保证下载执行程序时用户系统的安全。</p>			
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>RMI的劣势是什么？</p>				
				<p>RMI对服务器的IP地址和端口依赖很紧密，但是在开发的时候不知道将来的服务器IP和端口如何，但是客户端程序依赖这个IP和端口。这也是RMI的局限性之一。这个问题有两种解决途径：一是通过DNS来解决，二是通过封装将IP暴露到程序代码之外。
RMI的局限性之二是RMI是Java语言的远程调用，两端的程序语言必须是Java实现，对于不同语言间的通讯可以考虑用Web Service或者公用对象请求代理体系（CORBA）来实现。</p>
				<p></p>
			</section>
		</section>
		<section  class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<h3>4.编码实战</h3>
			</section>			
		</section>
		<section  class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<h3>5.扩展思考</h3>				
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>RPC与RMI的区别</p>
				<p> 1：方法调用方式不同：</p>
			    <p>RMI中是通过在客户端的Stub对象作为远程接口进行远程方法的调用。每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口(stub)上，那么这个新方法就不能被RMI客户方所调用。</p>
				<p> RPC中是通过网络服务协议向远程主机发送请求，请求包含了一个参数集和一个文本值，通常形成“classname.methodname(参数集)”的形式。RPC远程主机就去搜索与之相匹配的类和方法，找到后就执行方法并把结果编码，通过网络协议发回。</p>
			</section>
		
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
			    <p> 2：适用语言范围不同：</p>
			    <p>   RMI只用于Java；</p>
				<p>RPC是网络服务协议，与操作系统和语言无关。</p>
				<p></p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">				
			    <p>3：调用结果的返回形式不同：</p>
				<p>  Java是面向对象的，所以RMI的调用结果可以是对象类型或者基本数据类型； </p>
				<p>  RMI的结果统一由外部数据表示 (External Data Representation, XDR) 语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。</p>
			    <p></p>
				<p></p>
			</section>
		</section>
		<section>
			<h3>6.参考文献</h3>
			<p>https://www.cnblogs.com/ygj0930/p/6542811.html</p>
			<p>http://www.blogjava.net/zhenyu33154/articles/320245.html</p>
			
		</section>
        <section>
            <h3>7.更多讨论</h3>	
        </section>
        
        <section>
            <h3>分享到此结束</h3>
            <p></p>            
        </section>
        <section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">				
			</section>
		</section>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: './plugin/markdown/marked.js' },
            { src: './plugin/markdown/markdown.js' },
            { src: './plugin/notes/notes.js', async: true },
            { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
