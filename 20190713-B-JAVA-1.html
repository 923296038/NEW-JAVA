<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? './css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
	<style>
		.left{ text-align: left; }
	</style>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <p>Spring中的IOC是什么意思，为什么要用IOC而不是New来创建实例？</p>
		   
            <p>分享人：程政皓</p>	
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>  
            <p>4.解决方案</p>          
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
         <section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
            <section style="top: 267px; display: block;" class="" aria-hidden="true">
                <h3>1.背景介绍</h3>
            </section>
            <section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
            	<p>Spring框架是 Java 平台的一个开源的全栈（Full-stack）应用程序框架和控制反转容器实现，一般被直接称为 Spring。该框架的一些核心功能理论上可用于任何 Java 应用，但 Spring 还为基于Java企业版平台构建的 Web 应用提供了大量的拓展支持。虽然 Spring 没有直接实现任何的编程模型，但它已经在 Java 社区中广为流行，基本上完全代替了企业级JavaBeans（EJB）模型</p>
            	</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">	
				<p>Spring是一个容器，可以接管各个层次的Bean（action/domain/pojo/javabean），并且可以配置bean与bean之间的关系</p>
			<p>在java代码里使用bean只需要  用ApplicationContext 的getBean（配置文件里bean的id）方法就可以了</p>
				<p></p>
				<p></p>
				<p></p>
			</section>
			
            </section>
		    <section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
				<h3>2.知识剖析</h3>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>DI是什么？</p>
				<p>DI（Dependency Injection）,依赖注入，指容器复制创建和维护对象之间的依赖关系，而不是通过对象本身复制自己的创建和解决自己的依赖。控制反转是通过依赖注入实现的</p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<P>IOC是什么？</P>
				<p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 
其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）</p> 
            </section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
                <p>简单来说，Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期</p>
				<p></p>
				<p></p>
				<p></p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">			
				<p>IOC的作用？</p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>在Java开发中我们传统的、最基本的创建对象的方式是用new创建对象，这是一种主动的方式，即调用者需要一个类的实例，就会主动new一个出来，而IoC是依靠容器利用反射创建和查找依赖对象，并将依赖对象注入给调用者的，这也就产生了“依赖注入”这个概念，DI正是IoC最有威力的一部分。因为在一个类内部用new主要创建实例，就会导致类与类之间高耦合，而IoC则解决了这样的问题，便于测试和功能复用，更使得程序的整个体系结构变得非常灵活</p>
				<p></p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">				
				<p>IOC的框架？</p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>IoC容器主要有两种实现：org.springframework.beans.factory.BeanFactory(Bean工厂)和 
org.springframework.contextApplicationContext(应用上下文)，其中BeanFactory是Spring IoC最核心的部分，它实现了IoC的基本功能，ApplicationContext接口扩展了BeanFactory，还提供了与Spring AOP集成、国际化处理、资源访问、事件传播以及提供不同层次的context实现，简单地说，ApplicationContext 就是增加了更多支持企业级功能支持，所以现在一般情况下很少用BeanFactory，而是用ApplicationContext了</p>
				<p></p>
				<p></p>
			</section>					
		</section>
		<section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
				<h3>3.常见问题</h3>
			</section>	
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">				
				<p>实现控制反转主要有几种方式？</p>
				<p>IOC解决了什么问题</p>
				<p></p>
				<p></p>
			</section>
		</section>
		<section  class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
	        	<h3>4.解决方案</h3>
	        </section>	
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
	        	<p>有二种本别是：赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制</p>
        </section>	
		<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
	        	<p>在IoC出现以前，组件之间的协调关系是由程序内部代码来控制的，或者说，以前我们使用New关键字来实现两组间之间的依赖关系的。
                这种方式就造成了组件之间的互相耦合。IoC(控制反转)就是来解决这个问题的，它将实现组件间的关系从程序内部提到外部容器来管理。
                也就是说，由容器在运行期将组件间的某种依赖关系动态的注入组件中</p>
	        	<p></p>
	        </section>
		</section>
		<section  class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
				<h3>5.编码实战</h3>
			</section>			
		</section>
		<section  class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
				<h3>6.扩展思考</h3>				
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>AOP是什么？</p>
				<p>面向切面编程，往往被定义为促使软件系统实现关注点的分离的技术。系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件</p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>AOP相关的术语？</p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>通知定义了切面是什么以及何时使用的概念。Spring 切面可以应用5种类型的通知：</p>
				<p>1.前置通知（Before）：在目标方法被调用之前调用通知功能。
                2.后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么。
                3.返回通知（After-returning）：在目标方法成功执行之后调用通知。
                4.异常通知（After-throwing）：在目标方法抛出异常后调用通知。
                5.环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</p>
            </section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>
			   连接点：是在应用执行过程中能够插入切面的一个点。
               切点： 切点定义了切面在何处要织入的一个或者多个连接点。
               切面：是通知和切点的结合。通知和切点共同定义了切面的全部内容。
               引入：引入允许我们向现有类添加新方法或属性。
               织入：是把切面应用到目标对象，并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期中有多个点可以
               进行织入
            </section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
               编译期： 在目标类编译时，切面被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。
               类加载期：切面在目标加载到JVM时被织入。这种方式需要特殊的类加载器(class loader)它可以在目标类被引入应用之前增强该目标类的字节码。
               运行期： 切面在应用运行到某个时刻时被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面的</p>
		</section>
	</section>
		<section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
			<h3>7.参考文献</h3>
			<p>维基百科</p>
			<p>https://yinny.iteye.com/blog/1919999</p>
			<p>https://blog.csdn.net/gloomy_114/article/details/68946881</p>
			<p></p>
		</section>
        </section>
        <section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
            <h3>8.更多讨论</h3>	
        </section>
         </section>
        <section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
            <h3>分享到此结束</h3>
            <p></p>            
        </section>
        <section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">				
			</section>
		</section>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: './plugin/markdown/marked.js' },
            { src: './plugin/markdown/markdown.js' },
            { src: './plugin/notes/notes.js', async: true },
            { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
